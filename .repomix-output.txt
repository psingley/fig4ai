This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-09T16:40:36.934Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  generators/
    pseudo-generator.js
  processors/
    canvas-processor.js
    token-processor.js
  utils/
    api.js
    claude-api.js
    color.js
    url-parser.js
  index.js
.gitignore
FIG4AI_AI_INTEGRATION_FIX_PLAN.md
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/generators/pseudo-generator.js">
import OpenAI from 'openai';
import ora from 'ora';
import chalk from 'chalk';
import { rgbToHex } from '../utils/color.js';
import { ClaudeClient } from '../utils/claude-api.js';
let client;
let hasAICapability = false;
export function initializeAI(model = 'claude') {
    // Check if --no-ai flag is present
    if (process.argv.includes('--no-ai')) {
        hasAICapability = false;
        return;
    }
    try {
        if (model === 'gpt4' && process.env.OPENAI_API_KEY) {
            client = new OpenAI({
                apiKey: process.env.OPENAI_API_KEY
            });
            hasAICapability = true;
        } else if (model === 'claude' && process.env.CLAUDE_API_KEY) {
            client = new ClaudeClient(process.env.CLAUDE_API_KEY);
            hasAICapability = true;
        }
    } catch (error) {
        console.warn(chalk.yellow('Failed to initialize AI client:', error.message));
        hasAICapability = false;
    }
}
async function generatePseudoComponent(component, instance, tokens, figmaData) {
    if (!hasAICapability || !client) {
        return {
            componentName: component.name,
            pseudoCode: `# ${component.name}\n\`\`\`\n${JSON.stringify(instance, null, 2)}\n\`\`\``
        };
    }
    // Create a more detailed design system summary with exact values
    const designSystem = {
        typography: {
            headings: Object.fromEntries(
                Object.entries(tokens.typography.headings)
                    .map(([key, styles]) => [key, styles[0]?.style || null])
                    .filter(([_, style]) => style !== null)
            ),
            body: tokens.typography.body[0]?.style || null
        },
        colors: {
            primary: tokens.colors.primary.map(c => ({ 
                name: c.name, 
                hex: c.hex,
                rgb: `${c.color.r},${c.color.g},${c.color.b}`,
                opacity: c.opacity
            })),
            secondary: tokens.colors.secondary.map(c => ({ 
                name: c.name, 
                hex: c.hex,
                rgb: `${c.color.r},${c.color.g},${c.color.b}`,
                opacity: c.opacity
            })),
            text: tokens.colors.text.map(c => ({ 
                name: c.name, 
                hex: c.hex,
                rgb: `${c.color.r},${c.color.g},${c.color.b}`,
                opacity: c.opacity
            })),
            background: tokens.colors.background.map(c => ({ 
                name: c.name, 
                hex: c.hex,
                rgb: `${c.color.r},${c.color.g},${c.color.b}`,
                opacity: c.opacity
            })),
            other: tokens.colors.other.map(c => ({ 
                name: c.name, 
                hex: c.hex,
                rgb: `${c.color.r},${c.color.g},${c.color.b}`,
                opacity: c.opacity
            }))
        },
        spacing: tokens.spacing.map(s => ({
            name: s.name,
            value: s.itemSpacing,
            padding: s.padding
        })),
        effects: {
            shadows: tokens.effects.shadows.map(s => ({
                name: s.name,
                type: s.type,
                ...s.value,
                color: s.value.color ? {
                    hex: rgbToHex(
                        Math.round(s.value.color.r * 255),
                        Math.round(s.value.color.g * 255),
                        Math.round(s.value.color.b * 255)
                    ),
                    rgb: `${Math.round(s.value.color.r * 255)},${Math.round(s.value.color.g * 255)},${Math.round(s.value.color.b * 255)}`,
                    opacity: s.value.color.a
                } : null
            })),
            blurs: tokens.effects.blurs.map(b => ({
                name: b.name,
                type: b.type,
                ...b.value
            }))
        }
    };
    // Extract component-specific styles and references
    const componentStyles = {
        styles: {},  // Will be populated with expanded styles
        fills: instance.fills?.map(fill => {
            if (fill.type === 'SOLID') {
                // Check if this fill comes from a style
                const styleId = instance.styles?.fills || instance.styles?.fill;
                if (styleId) {
                    // Find the style in tokens
                    const style = tokens.styles.find(s => s.id === styleId);
                    // Find the actual style definition in the Figma data
                    const styleDefinition = figmaData.styles?.[styleId];
                    return {
                        type: fill.type,
                        styleId,
                        styleName: style?.name || 'Unknown Style',
                        styleType: 'fill',
                        description: styleDefinition?.description || null,
                        color: {
                            hex: rgbToHex(
                                Math.round(fill.color.r * 255),
                                Math.round(fill.color.g * 255),
                                Math.round(fill.color.b * 255)
                            ),
                            rgb: `${Math.round(fill.color.r * 255)},${Math.round(fill.color.g * 255)},${Math.round(fill.color.b * 255)}`,
                            opacity: fill.color.a
                        }
                    };
                }
                return {
                    type: fill.type,
                    color: {
                        hex: rgbToHex(
                            Math.round(fill.color.r * 255),
                            Math.round(fill.color.g * 255),
                            Math.round(fill.color.b * 255)
                        ),
                        rgb: `${Math.round(fill.color.r * 255)},${Math.round(fill.color.g * 255)},${Math.round(fill.color.b * 255)}`,
                        opacity: fill.color.a
                    }
                };
            }
            return fill;
        }),
        effects: instance.effects?.map(effect => {
            const styleId = instance.styles?.effects || instance.styles?.effect;
            if (styleId) {
                const style = tokens.styles.find(s => s.id === styleId);
                const styleDefinition = figmaData.styles?.[styleId];
                return {
                    type: effect.type,
                    styleId,
                    styleName: style?.name || 'Unknown Style',
                    styleType: 'effect',
                    description: styleDefinition?.description || null,
                    value: {
                        ...effect,
                        color: effect.color ? {
                            hex: rgbToHex(
                                Math.round(effect.color.r * 255),
                                Math.round(effect.color.g * 255),
                                Math.round(effect.color.b * 255)
                            ),
                            rgb: `${Math.round(effect.color.r * 255)},${Math.round(effect.color.g * 255)},${Math.round(effect.color.b * 255)}`,
                            opacity: effect.color.a
                        } : null
                    }
                };
            }
            return effect;
        })
    };
    // Expand all style references
    if (instance.styles) {
        Object.entries(instance.styles).forEach(([key, styleId]) => {
            const style = tokens.styles.find(s => s.id === styleId);
            const styleDefinition = figmaData.styles?.[styleId];
            componentStyles.styles[key] = {
                id: styleId,
                name: style?.name || 'Unknown Style',
                type: key,
                description: styleDefinition?.description || null,
                value: styleDefinition || null
            };
        });
    }
    const functions = [
        {
            name: "create_pseudo_component",
            description: "Generate a pseudo-XML component based on Figma component details",
            parameters: {
                type: "object",
                properties: {
                    componentName: {
                        type: "string",
                        description: "The name of the component"
                    },
                    pseudoCode: {
                        type: "string",
                        description: "The pseudo-XML code for the component with detailed styling"
                    }
                },
                required: ["componentName", "pseudoCode"]
            }
        }
    ];
    const prompt = `Design System Details:
\`\`\`
${JSON.stringify(designSystem, null, 2)}
\`\`\`
Component to Generate:
Name: ${component.name}
Type: ${component.type}
Description: ${component.description || 'No description provided'}
Size: ${instance.size.width}x${instance.size.height}
Component Specific Styles and References:
\`\`\`
${JSON.stringify(componentStyles, null, 2)}
\`\`\`
Requirements:
1. Generate pseudo-XML code that represents this component
2. Use style references (styleId) when available instead of direct values
3. Include ALL styling details (colors, shadows, effects)
4. Use exact color values (HEX and RGB) when no style reference exists
5. Include shadow and effect details with style references
6. Specify padding and spacing
7. Include background colors and gradients
8. Make it accessible
9. Keep it readable
Example format:
<Button 
  fills="style_id_123"
  effects="style_id_456"
  strokes="style_id_789"
  padding="8px 16px"
  border-radius="4px"
>
  <Icon name="star" fills="style_id_234" />
  <Text fills="style_id_567" font-size="16px">Click me</Text>
</Button>
Generate ONLY the pseudo-XML code with detailed styling attributes, preferring style references over direct values.`;
    try {
        const completion = await client.chat(
            [{ role: "user", content: prompt }],
            functions,
            { name: "create_pseudo_component" }
        );
        const response = JSON.parse(completion.choices[0].message.function_call.arguments);
        return response;
    } catch (error) {
        console.warn(chalk.yellow(`Skipping pseudo generation for component ${component.name} - ${error.message}`));
        return {
            componentName: component.name,
            pseudoCode: `# ${component.name}\n${JSON.stringify(instance, null, 2)}`
        };
    }
}
async function generatePseudoFrame(frame, components, tokens, canvas) {
    if (!hasAICapability || !client) {
        return {
            frameName: frame.name,
            pseudoCode: `# ${frame.name} (Canvas: ${canvas.name})\n${JSON.stringify(frame, null, 2)}`
        };
    }
    const functions = [
        {
            name: "create_pseudo_frame",
            description: "Generate a pseudo-XML frame layout based on Figma frame details",
            parameters: {
                type: "object",
                properties: {
                    frameName: {
                        type: "string",
                        description: "The name of the frame"
                    },
                    pseudoCode: {
                        type: "string",
                        description: "The pseudo-XML code for the frame layout"
                    }
                },
                required: ["frameName", "pseudoCode"]
            }
        }
    ];
    // Extract frame dimensions and properties for the summary
    const frameSize = frame.absoluteBoundingBox ? {
        width: frame.absoluteBoundingBox.width,
        height: frame.absoluteBoundingBox.height
    } : { width: 0, height: 0 };
    const framePadding = {
        top: frame.paddingTop || 0,
        right: frame.paddingRight || 0,
        bottom: frame.paddingBottom || 0,
        left: frame.paddingLeft || 0
    };
    const canvasSize = canvas.absoluteBoundingBox ? {
        width: canvas.absoluteBoundingBox.width,
        height: canvas.absoluteBoundingBox.height
    } : { width: 0, height: 0 };
    const prompt = `Frame Summary:
Name: ${frame.name}
Size: ${frameSize.width}x${frameSize.height}
Layout: ${frame.layoutMode || 'FREE'}
Spacing: ${frame.itemSpacing || 0}
Padding: ${JSON.stringify(framePadding)}
Elements: ${frame.children?.length || 0}
Position: x=${frame.absoluteBoundingBox?.x || 0}, y=${frame.absoluteBoundingBox?.y || 0}
Canvas Summary:
Name: ${canvas.name}
Type: ${canvas.type}
Size: ${canvasSize.width}x${canvasSize.height}
Available Components:
${components.map(c => `- ${c.name}`).join('\n')}
Complete Frame Data:
\`\`\`
${JSON.stringify(frame, null, 2)}
\`\`\`
Complete Canvas Data:
\`\`\`
${JSON.stringify(canvas, null, 2)}
\`\`\`
Requirements:
1. Generate pseudo-XML layout code for this frame
2. Use semantic container elements
3. Include layout attributes (flex, grid, etc.)
4. Use appropriate spacing and padding
5. Place components in a logical layout
6. Consider canvas context for positioning and constraints
7. Include all text content exactly as specified in the frame data
8. Preserve all styling information from the frame data
9. Keep the hierarchy of nested elements
10. Keep it readable while being accurate to the source data
Example format:
<Frame 
  name="${frame.name}" 
  layout="${frame.layoutMode || 'FREE'}" 
  spacing="${frame.itemSpacing || 0}" 
  canvas="${canvas.name}"
  position="x=${frame.absoluteBoundingBox?.x || 0},y=${frame.absoluteBoundingBox?.y || 0}"
  size="w=${frameSize.width},h=${frameSize.height}"
  constraints="${JSON.stringify(frame.constraints)}"
  background="${JSON.stringify(frame.backgroundColor)}"
  blendMode="${frame.blendMode}"
  clipsContent="${frame.clipsContent}"
>
  <!-- Generate nested elements based on frame.children -->
  <!-- Include all text content, styles, and properties -->
  <!-- Use style references when available -->
</Frame>
Generate ONLY the pseudo-XML code without any additional explanation. Ensure all text content and styling from the frame data is accurately represented.`;
    try {
        const completion = await client.chat(
            [{ role: "user", content: prompt }],
            functions,
            { name: "create_pseudo_frame" }
        );
        const response = JSON.parse(completion.choices[0].message.function_call.arguments);
        return response;
    } catch (error) {
        console.warn(chalk.yellow(`Skipping pseudo generation for frame ${frame.name} - ${error.message}`));
        return {
            frameName: frame.name,
            pseudoCode: `# ${frame.name} (Canvas: ${canvas.name})\n${JSON.stringify(frame, null, 2)}`
        };
    }
}
export async function generateAllPseudoCode(components, instances, frames, tokens, figmaData) {
    const pseudoComponents = new Map();
    const spinner = ora();
    if (!hasAICapability) {
        spinner.info('Running without AI enhancement - will output raw data');
    }
    // Generate components first
    spinner.start('Processing components...');
    for (const component of components) {
        spinner.text = `Processing component: ${component.name}`;
        const componentInstances = instances.filter(i => i.componentId === component.id);
        if (componentInstances.length > 0) {
            const mainInstance = componentInstances[0];
            const pseudoComponent = await generatePseudoComponent(component, mainInstance, tokens, figmaData);
            if (pseudoComponent) {
                pseudoComponents.set(component.id, pseudoComponent);
                spinner.stop();
                console.log(chalk.green(`✓ Processed component: ${component.name}`));
                spinner.start();
            }
        }
    }
    spinner.succeed('All components processed');
    spinner.start('Processing frame layouts...');
    const pseudoFrames = new Map();
    // Generate frames using the components
    for (const canvas of figmaData.document.children) {
        spinner.stop();
        console.log(chalk.blue(`\nProcessing canvas: ${canvas.name}`));
        spinner.start();
        for (const frame of canvas.children?.filter(child => child.type === 'FRAME') || []) {
            spinner.text = `Processing frame: ${frame.name}`;
            const pseudoFrame = await generatePseudoFrame(frame, components, tokens, canvas);
            if (pseudoFrame) {
                pseudoFrames.set(frame.id, pseudoFrame);
                spinner.stop();
                console.log(chalk.green(`  ✓ Processed frame: ${frame.name}`));
                spinner.start();
            }
        }
    }
    spinner.succeed('All frames processed');
    return { components: pseudoComponents, frames: pseudoFrames };
}
</file>

<file path="src/processors/canvas-processor.js">
export function processCanvases(document) {
    if (!document || !document.children) return [];
    return document.children.map(canvas => {
        const frames = canvas.children
            ?.filter(child => child.type === 'FRAME')
            ?.map(frame => ({
                id: frame.id,
                name: frame.name,
                type: frame.type,
                size: {
                    width: frame.absoluteBoundingBox?.width || null,
                    height: frame.absoluteBoundingBox?.height || null
                },
                position: {
                    x: frame.x || 0,
                    y: frame.y || 0
                },
                background: frame.backgroundColor,
                layoutMode: frame.layoutMode,
                itemSpacing: frame.itemSpacing,
                padding: {
                    top: frame.paddingTop,
                    right: frame.paddingRight,
                    bottom: frame.paddingBottom,
                    left: frame.paddingLeft
                },
                constraints: frame.constraints,
                clipsContent: frame.clipsContent,
                elements: frame.children?.length || 0
            })) || [];
        return {
            id: canvas.id,
            name: canvas.name,
            type: canvas.type,
            backgroundColor: canvas.backgroundColor,
            children: canvas.children ? canvas.children.length : 0,
            size: {
                width: canvas.absoluteBoundingBox?.width || null,
                height: canvas.absoluteBoundingBox?.height || null
            },
            constraints: canvas.constraints || null,
            exportSettings: canvas.exportSettings || [],
            flowStartingPoints: canvas.flowStartingPoints || [],
            prototypeStartNode: canvas.prototypeStartNode || null,
            frames
        };
    });
}
export function processComponentInstances(node, instances = [], parentName = '') {
    if (!node) return instances;
    const fullName = parentName ? `${parentName}/${node.name}` : node.name;
    if (node.type === 'INSTANCE') {
        instances.push({
            id: node.id,
            name: fullName,
            componentId: node.componentId,
            mainComponent: node.mainComponent,
            styles: node.styles || null,
            position: {
                x: node.x || 0,
                y: node.y || 0
            },
            size: {
                width: node.absoluteBoundingBox?.width || null,
                height: node.absoluteBoundingBox?.height || null
            }
        });
    }
    if (node.children) {
        node.children.forEach(child => {
            processComponentInstances(child, instances, fullName);
        });
    }
    return instances;
}
export function generateComponentYAML(components, instances) {
    // Create a map of component IDs to their instances
    const componentMap = new Map();
    components.forEach(comp => {
        componentMap.set(comp.id, {
            name: comp.name,
            type: comp.type,
            description: comp.description,
            instances: []
        });
    });
    // Map instances to their components
    instances.forEach(instance => {
        if (componentMap.has(instance.componentId)) {
            componentMap.get(instance.componentId).instances.push({
                id: instance.id,
                name: instance.name
            });
        }
    });
    // Generate YAML-like string
    let yaml = 'components:\n';
    componentMap.forEach((value, key) => {
        yaml += `  ${key}:\n`;
        yaml += `    name: "${value.name}"\n`;
        yaml += `    type: ${value.type}\n`;
        if (value.description) {
            yaml += `    description: "${value.description}"\n`;
        }
        if (value.instances.length > 0) {
            yaml += '    instances:\n';
            value.instances.forEach(instance => {
                yaml += `      - id: ${instance.id}\n`;
                yaml += `        name: "${instance.name}"\n`;
            });
        }
        yaml += '\n';
    });
    return yaml;
}
</file>

<file path="src/processors/token-processor.js">
import { rgbToHex } from '../utils/color.js';
export function processDesignTokens(node, tokens = {
    typography: {
        headings: {
            h1: [], h2: [], h3: [], h4: [], h5: [], h6: []
        },
        body: [],
        other: []
    },
    colors: {
        primary: [],
        secondary: [],
        text: [],
        background: [],
        other: []
    },
    spacing: [],
    effects: {
        shadows: [],
        blurs: [],
        other: []
    },
    components: [],
    styles: []
}, parentName = '') {
    if (!node) return tokens;
    const fullName = parentName ? `${parentName}/${node.name}` : node.name;
    const nameLower = node.name.toLowerCase();
    // Process node based on type
    switch (node.type) {
        case 'COMPONENT':
        case 'COMPONENT_SET':
            tokens.components.push({
                id: node.id,
                name: fullName,
                type: node.type,
                description: node.description || null,
                styles: node.styles || null
            });
            break;
        case 'TEXT':
            const textStyle = {
                id: node.id,
                name: fullName,
                content: node.characters,
                style: {
                    fontFamily: node.style?.fontFamily,
                    fontWeight: node.style?.fontWeight,
                    fontSize: node.style?.fontSize,
                    lineHeight: node.style?.lineHeightPx || node.style?.lineHeight,
                    letterSpacing: node.style?.letterSpacing,
                    textCase: node.style?.textCase,
                    textDecoration: node.style?.textDecoration,
                    textAlignHorizontal: node.style?.textAlignHorizontal,
                    paragraphSpacing: node.style?.paragraphSpacing,
                    fills: node.fills
                }
            };
            // Categorize typography
            if (nameLower.includes('heading') || nameLower.match(/h[1-6]/)) {
                const headingLevel = nameLower.match(/h([1-6])/)?.[1];
                if (headingLevel) {
                    tokens.typography.headings[`h${headingLevel}`].push(textStyle);
                }
            } else if (nameLower.includes('body') || nameLower.includes('text') || nameLower.includes('paragraph')) {
                tokens.typography.body.push(textStyle);
            } else {
                tokens.typography.other.push(textStyle);
            }
            break;
        case 'RECTANGLE':
        case 'VECTOR':
        case 'ELLIPSE':
            if (node.fills && node.fills.length > 0) {
                node.fills.forEach(fill => {
                    if (fill.type === 'SOLID') {
                        const colorToken = {
                            id: node.id,
                            name: fullName,
                            color: {
                                r: Math.round(fill.color.r * 255),
                                g: Math.round(fill.color.g * 255),
                                b: Math.round(fill.color.b * 255),
                                a: fill.color.a,
                            },
                            hex: rgbToHex(
                                Math.round(fill.color.r * 255),
                                Math.round(fill.color.g * 255),
                                Math.round(fill.color.b * 255)
                            ),
                            opacity: fill.color.a
                        };
                        // Categorize colors
                        if (nameLower.includes('primary')) {
                            tokens.colors.primary.push(colorToken);
                        } else if (nameLower.includes('secondary')) {
                            tokens.colors.secondary.push(colorToken);
                        } else if (nameLower.includes('text') || nameLower.includes('typography')) {
                            tokens.colors.text.push(colorToken);
                        } else if (nameLower.includes('background') || nameLower.includes('bg')) {
                            tokens.colors.background.push(colorToken);
                        } else {
                            tokens.colors.other.push(colorToken);
                        }
                    }
                });
            }
            // Process effects
            if (node.effects && node.effects.length > 0) {
                node.effects.forEach(effect => {
                    const effectToken = {
                        id: node.id,
                        name: fullName,
                        type: effect.type,
                        value: effect
                    };
                    if (effect.type === 'DROP_SHADOW' || effect.type === 'INNER_SHADOW') {
                        tokens.effects.shadows.push(effectToken);
                    } else if (effect.type === 'LAYER_BLUR' || effect.type === 'BACKGROUND_BLUR') {
                        tokens.effects.blurs.push(effectToken);
                    } else {
                        tokens.effects.other.push(effectToken);
                    }
                });
            }
            break;
        case 'FRAME':
            // Process spacing from auto-layout frames
            if (node.layoutMode === 'VERTICAL' || node.layoutMode === 'HORIZONTAL') {
                tokens.spacing.push({
                    id: node.id,
                    name: fullName,
                    type: node.layoutMode,
                    itemSpacing: node.itemSpacing,
                    padding: {
                        top: node.paddingTop,
                        right: node.paddingRight,
                        bottom: node.paddingBottom,
                        left: node.paddingLeft
                    }
                });
            }
            break;
    }
    // Process styles if present
    if (node.styles) {
        tokens.styles.push({
            id: node.id,
            name: fullName,
            styles: node.styles
        });
    }
    // Recursively process children
    if (node.children) {
        node.children.forEach(child => {
            processDesignTokens(child, tokens, fullName);
        });
    }
    return tokens;
}
export function formatTokenCount(tokens) {
    let counts = {
        typography: Object.values(tokens.typography.headings).flat().length + 
                   tokens.typography.body.length + 
                   tokens.typography.other.length,
        colors: Object.values(tokens.colors).flat().length,
        effects: Object.values(tokens.effects).flat().length,
        spacing: tokens.spacing.length,
        components: tokens.components.length,
        styles: tokens.styles.length
    };
    return Object.entries(counts)
        .map(([key, value]) => `${key}: ${value}`)
        .join(', ');
}
</file>

<file path="src/utils/api.js">
import fetch from 'node-fetch';
export async function getFigmaFileData(fileId) {
    const response = await fetch(`https://api.figma.com/v1/files/${fileId}`, {
        headers: {
            'X-Figma-Token': process.env.FIGMA_ACCESS_TOKEN
        }
    });
    if (!response.ok) {
        throw new Error(`Figma API error: ${response.statusText}`);
    }
    return response.json();
}
</file>

<file path="src/utils/claude-api.js">
import Anthropic from '@anthropic-ai/sdk';
export class ClaudeClient {
    constructor(apiKey) {
        this.client = new Anthropic({
            apiKey: apiKey
        });
    }
    async chat(messages, functions, functionCall) {
        try {
            const systemPrompt = functions ? 
                `You are a function calling AI. Available functions: ${JSON.stringify(functions)}. 
                When responding, you must call one of these functions using the exact format:
                {"name": "function_name", "arguments": {arg1: value1, arg2: value2}}` : undefined;
            const response = await this.client.messages.create({
                model: 'claude-3-sonnet-20240229',
                max_tokens: 4096,
                temperature: 0.7,
                system: systemPrompt,
                messages: messages.map(msg => ({
                    role: msg.role === 'user' ? 'user' : 'assistant',
                    content: msg.content
                })),
                tools: functions ? [{
                    type: 'function',
                    function: {
                        name: functions[0].name,
                        description: functions[0].description,
                        parameters: functions[0].parameters
                    }
                }] : undefined
            });
            if (functions) {
                // Handle Claude 3 tool calls
                const toolCalls = response.content
                    .filter(content => content.type === 'tool_call')
                    .map(content => content.tool_call);
                if (toolCalls && toolCalls.length > 0) {
                    const toolCall = toolCalls[0];
                    return {
                        choices: [{
                            message: {
                                function_call: {
                                    name: toolCall.function.name,
                                    arguments: toolCall.function.arguments
                                }
                            }
                        }]
                    };
                }
                // Fallback: try to parse function call from text response
                const textContent = response.content
                    .filter(content => content.type === 'text')
                    .map(content => content.text)
                    .join('\n');
                try {
                    const match = textContent.match(/\{(?:[^{}]|{[^{}]*})*\}/);
                    if (match) {
                        const parsedCall = JSON.parse(match[0]);
                        if (parsedCall.name && parsedCall.arguments) {
                            return {
                                choices: [{
                                    message: {
                                        function_call: {
                                            name: parsedCall.name,
                                            arguments: JSON.stringify(parsedCall.arguments)
                                        }
                                    }
                                }]
                            };
                        }
                    }
                    throw new Error('No valid function call found in response');
                } catch (error) {
                    console.error('Error parsing function call from Claude response:', error);
                    throw new Error('Failed to parse function call from response');
                }
            }
            // Handle regular text response
            const textContent = response.content
                .filter(content => content.type === 'text')
                .map(content => content.text)
                .join('\n');
            return {
                choices: [{
                    message: {
                        content: textContent
                    }
                }]
            };
        } catch (error) {
            if (error.message === 'Failed to parse function call from response') {
                throw error;
            }
            throw new Error(`Claude API error: ${error.message}`);
        }
    }
}
</file>

<file path="src/utils/color.js">
export function rgbToHex(r, g, b) {
    const toHex = (n) => {
        const hex = n.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}
</file>

<file path="src/utils/url-parser.js">
export function parseFigmaUrl(url) {
    try {
        // Handle URLs without protocol
        const urlWithProtocol = url.startsWith('http') ? url : `https://${url}`;
        const urlObj = new URL(urlWithProtocol);
        if (!urlObj.hostname.includes('figma.com')) {
            throw new Error('Not a valid Figma URL');
        }
        const pathParts = urlObj.pathname.split('/').filter(Boolean);
        const fileId = pathParts[1];
        const nodeId = urlObj.searchParams.get('node-id');
        // Extract additional parameters
        const page = urlObj.searchParams.get('p');
        const type = urlObj.searchParams.get('t');
        const title = pathParts[2] ? decodeURIComponent(pathParts[2]) : null;
        return {
            type: pathParts[0], // 'file' or 'design'
            fileId,
            nodeId,
            page,
            viewType: type,
            title,
            fullPath: urlObj.pathname,
            originalUrl: url,
            params: Object.fromEntries(urlObj.searchParams)
        };
    } catch (error) {
        throw new Error('Invalid URL format');
    }
}
</file>

<file path="src/index.js">
#!/usr/bin/env node
// Suppress punycode deprecation warning
process.noDeprecation = true;
import chalk from 'chalk';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';
import ora from 'ora';
import { parseFigmaUrl } from './utils/url-parser.js';
import { getFigmaFileData } from './utils/api.js';
import { processDesignTokens, formatTokenCount } from './processors/token-processor.js';
import { processCanvases, processComponentInstances, generateComponentYAML } from './processors/canvas-processor.js';
import { generateAllPseudoCode, initializeAI } from './generators/pseudo-generator.js';
// Load environment variables
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
dotenv.config({ path: join(dirname(__dirname), '.env') });
// Validate required environment variables
const requiredEnvVars = {
    'FIGMA_ACCESS_TOKEN': process.env.FIGMA_ACCESS_TOKEN
};
// Optional environment variables
const optionalEnvVars = {
    'OPENAI_API_KEY': process.env.OPENAI_API_KEY,
    'CLAUDE_API_KEY': process.env.CLAUDE_API_KEY
};
const missingEnvVars = Object.entries(requiredEnvVars)
    .filter(([_, value]) => !value)
    .map(([key]) => key);
if (missingEnvVars.length > 0) {
    console.error(chalk.red('\nMissing required environment variables:'));
    missingEnvVars.forEach(envVar => {
        console.error(chalk.yellow(`  • ${envVar}`));
    });
    console.error(chalk.blue('\nPlease set these variables in your .env file:'));
    console.error(chalk.gray('\n# .env'));
    missingEnvVars.forEach(envVar => {
        console.error(chalk.gray(`${envVar}=your_${envVar.toLowerCase()}_here`));
    });
    process.exit(1);
}
// Parse command line arguments
const args = process.argv.slice(2);
const figmaUrl = args[0] || process.env.FIGMA_DESIGN_URL;
const modelArg = args.find(arg => arg.startsWith('--model='));
const noAI = args.includes('--no-ai');
const model = modelArg ? modelArg.split('=')[1].toLowerCase() : 'claude';
if (!figmaUrl) {
    console.error(chalk.red('Please provide a Figma URL'));
    console.log(chalk.blue('\nUsage:'));
    console.log('  npx fig4ai <figma-url> [--model=claude|gpt4] [--no-ai]');
    console.log(chalk.blue('\nOptions:'));
    console.log('  --model=claude|gpt4    Choose AI model (default: claude)');
    console.log('  --no-ai                Skip AI enhancements and output raw data');
    console.log(chalk.blue('\nOr set it in your .env file:'));
    console.log(chalk.gray('FIGMA_DESIGN_URL=your_figma_url_here'));
    process.exit(1);
}
// Check if AI enhancement is possible and desired
const hasAICapability = !noAI && ((model === 'claude' && process.env.CLAUDE_API_KEY) || 
                                 (model === 'gpt4' && process.env.OPENAI_API_KEY));
if (noAI) {
    console.info(chalk.blue('\nAI enhancement disabled via --no-ai flag.'));
} else if (!hasAICapability) {
    console.warn(chalk.yellow('\nNo AI API keys found. Running without AI enhancement.'));
    console.warn(chalk.gray('To enable AI features, set CLAUDE_API_KEY or OPENAI_API_KEY in your .env file.'));
}
async function main() {
    const spinner = ora();
    try {
        // Initialize AI with selected model
        initializeAI(model);
        const result = parseFigmaUrl(figmaUrl);
        let output = '';
        // Capture URL details
        output += '# Figma Design Rules\n\n';
        output += '## File Information\n';
        output += `Type: ${result.type}\n`;
        output += `File ID: ${result.fileId}\n`;
        output += `Title: ${result.title || 'Not specified'}\n`;
        output += `Node ID: ${result.nodeId || 'Not specified'}\n\n`;
        spinner.start('Processing Figma URL details...');
        spinner.succeed('Figma URL details processed');
        spinner.start('Fetching file data from Figma API...');
        const figmaData = await getFigmaFileData(result.fileId);
        spinner.succeed('Figma file data fetched');
        output += `File Name: ${figmaData.name}\n`;
        output += `Last Modified: ${new Date(figmaData.lastModified).toLocaleString()}\n\n`;
        spinner.start('Processing design tokens...');
        const tokens = processDesignTokens(figmaData.document);
        spinner.succeed('Design tokens processed');
        // Add token summary
        output += '## Design Tokens Summary\n';
        output += formatTokenCount(tokens) + '\n\n';
        spinner.info(`Total tokens found: ${formatTokenCount(tokens)}`);
        // Process and capture detailed token information
        spinner.start('Processing typography tokens...');
        output += '## Typography\n\n';
        Object.entries(tokens.typography.headings).forEach(([level, styles]) => {
            if (styles.length > 0) {
                output += `### ${level.toUpperCase()}\n`;
                styles.forEach(style => {
                    output += `- ${style.name}\n`;
                    output += `  - Font: ${style.style.fontFamily} (${style.style.fontWeight})\n`;
                    output += `  - Size: ${style.style.fontSize}px\n`;
                    output += `  - Line Height: ${style.style.lineHeight}\n`;
                    if (style.style.letterSpacing) {
                        output += `  - Letter Spacing: ${style.style.letterSpacing}\n`;
                    }
                    output += '\n';
                });
            }
        });
        spinner.succeed('Typography tokens processed');
        spinner.start('Processing color tokens...');
        output += '## Colors\n\n';
        Object.entries(tokens.colors).forEach(([category, colors]) => {
            if (colors.length > 0) {
                output += `### ${category.toUpperCase()}\n`;
                colors.forEach(color => {
                    output += `- ${color.name}\n`;
                    output += `  - HEX: ${color.hex}\n`;
                    output += `  - RGB: ${color.color.r}, ${color.color.g}, ${color.color.b}\n`;
                    if (color.opacity !== 1) {
                        output += `  - Opacity: ${color.opacity}\n`;
                    }
                    output += '\n';
                });
            }
        });
        spinner.succeed('Color tokens processed');
        // Process canvas information
        spinner.start('Processing canvas information...');
        const canvases = processCanvases(figmaData.document);
        output += '## Canvases and Frames\n\n';
        canvases.forEach(canvas => {
            output += `### ${canvas.name}\n`;
            output += `- ID: ${canvas.id}\n`;
            output += `- Type: ${canvas.type}\n`;
            output += `- Total Elements: ${canvas.children}\n`;
            if (canvas.frames && canvas.frames.length > 0) {
                output += `\n#### Frames (${canvas.frames.length})\n`;
                canvas.frames.forEach(frame => {
                    output += `\n##### ${frame.name}\n`;
                    output += `- ID: ${frame.id}\n`;
                    if (frame.size.width && frame.size.height) {
                        output += `- Size: ${frame.size.width}x${frame.size.height}\n`;
                    }
                    if (frame.layoutMode) {
                        output += `- Layout: ${frame.layoutMode}\n`;
                        output += `- Item Spacing: ${frame.itemSpacing}\n`;
                    }
                });
            }
            output += '\n';
        });
        spinner.succeed('Canvas information processed');
        // Process component instances
        spinner.start('Processing component instances...');
        const instances = processComponentInstances(figmaData.document);
        output += '## Component Instances\n\n';
        instances.forEach(instance => {
            output += `### ${instance.name}\n`;
            output += `- ID: ${instance.id}\n`;
            output += `- Component ID: ${instance.componentId}\n`;
            if (instance.size.width && instance.size.height) {
                output += `- Size: ${instance.size.width}x${instance.size.height}\n`;
            }
            output += '\n';
        });
        spinner.succeed('Component instances processed');
        // Generate component structure
        spinner.start('Generating component structure...');
        output += '## Component Structure\n\n```yaml\n';
        const componentYAML = generateComponentYAML(tokens.components, instances);
        output += componentYAML;
        output += '```\n\n';
        spinner.succeed('Component structure generated');
        // Generate pseudo components and frames
        spinner.start('Generating pseudo components and frames...');
        const frames = canvases.flatMap(canvas => canvas.frames);
        const pseudoCode = await generateAllPseudoCode(tokens.components, instances, frames, tokens, figmaData);
        spinner.succeed('Pseudo components and frames generated');
        // Add pseudo code
        output += '## Pseudo Components\n\n```xml\n';
        pseudoCode.components.forEach((component, id) => {
            output += component.pseudoCode + '\n\n';
        });
        output += '```\n\n';
        output += '## Frame Layouts\n\n```xml\n';
        pseudoCode.frames.forEach((frame, id) => {
            output += frame.pseudoCode + '\n\n';
        });
        output += '```\n';
        // Save to .designrules file
        spinner.start('Saving design rules...');
        await fs.promises.writeFile('.designrules', output);
        spinner.succeed('Design rules saved successfully');
    } catch (error) {
        spinner.fail(chalk.red('Error: ' + error.message));
        process.exit(1);
    }
}
main();
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

example/
.designrules# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

.designrules
.env
</file>

<file path="FIG4AI_AI_INTEGRATION_FIX_PLAN.md">
# Fig4ai AI Integration Fix Plan

## Overview
Fix the AI integration in fig4ai to properly handle both Claude and GPT-4 models, focusing on the error: "client.chat is not a function".

## Impact Analysis Summary
- **Direct Impact**: 
  - `src/utils/claude-api.js`
  - `src/utils/api.js`
  - `src/generators/pseudo-generator.js`
- **Indirect Impact**: 
  - AI model integration
  - Command line interface
  - Design token processing
- **Risk Level**: Medium - Changes to core AI functionality

## Tasks

### Phase 1: Investigation
- [ ] 1.1. Code Analysis
  - [ ] Review current AI client implementation
  - [ ] Trace error in function calls
  - [ ] Document API version requirements
  - [ ] Check environment variable handling

- [ ] 1.2. Environment Setup
  - [ ] Set up development environment
  - [ ] Configure test cases
  - [ ] Verify API keys and access

### Phase 2: Implementation
- [ ] 2.1. Fix AI Client Integration
  - [ ] Update Claude API client
  - [ ] Update OpenAI API client
  - [ ] Implement proper error handling
  - [ ] Add API version checks

- [ ] 2.2. Testing
  - [ ] Test with Claude model
  - [ ] Test with GPT-4 model
  - [ ] Test without AI (--no-ai flag)
  - [ ] Verify error handling

### Phase 3: Documentation
- [ ] 3.1. Update Documentation
  - [ ] Document API requirements
  - [ ] Update usage examples
  - [ ] Add troubleshooting section

## Error Tracking
```typescript
File: src/utils/claude-api.js
Error: client.chat is not a function
Attempted Solution: Investigating current implementation
Result: Pending
```

## Progress Updates

### Latest Status
- **Current Phase**: Investigation
- **Last Updated**: Current
- **Current Task**: Code Analysis
- **Current Blockers**: None

### Completed Tasks
- Repository forked and cloned
- Initial error reproduction confirmed

### Failed Attempts
None yet

### Test Results
Pending

## Notes
- Focus on maintaining backward compatibility
- Consider adding version checks for API clients
- Document any API version requirements
- Consider adding debug mode for troubleshooting
</file>

<file path="package.json">
{
  "name": "fig4ai",
  "version": "0.1.5",
  "description": "A CLI tool to parse Figma URLs and generate AI-powered design rules for your AI editor.",
  "main": "src/index.js",
  "bin": {
    "fig4ai": "./src/index.js"
  },
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "fig4ai": "node src/index.js"
  },
  "keywords": [
    "figma",
    "cli",
    "url-parser",
    "ai",
    "design-rules"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.33.1",
    "chalk": "^5.3.0",
    "dotenv": "^16.3.1",
    "node-fetch": "^3.3.2",
    "openai": "^4.24.1",
    "ora": "^7.0.1"
  }
}
</file>

<file path="README.md">
# fig4ai

![License](https://img.shields.io/badge/license-MIT-blue.svg)

A CLI tool that uses AI to generate design rules and documentation from your Figma files. It analyzes your Figma designs and automatically extracts design tokens, components, and layout information into a structured format.

## Overview



https://github.com/user-attachments/assets/c80b7eee-7027-4872-ae30-5279289ff6f7



## Features

- 🎨 Extract design tokens (colors, typography, spacing, effects)
- 🧩 Generate component documentation
- 📐 Analyze layout structures
- 🤖 AI-powered pseudo-code generation
- 🔄 Real-time progress indicators
- 📝 Markdown output format

## Run
Run directly with npx:

```bash
npx fig4ai <figma-url> [--model=claude|gpt4] [--no-ai]
```

## IDE Integration

After generating your `.designrules` file, you can use it with AI-powered IDEs to automatically generate code and configurations:

### Cursor, Windsurf, VS Code

Simply mention the `.designrules` file in your prompts:

```
> Generate a Tailwind config based on @.designrules file
```
```
> Create a Vue login page using the design tokens from @.designrules
```
```
> Build a React component library following @.designrules specifications
```


The AI will analyze your `.designrules` file and generate code that matches your design system's:
- Color palette
- Typography scales
- Spacing system
- Component structures
- Layout patterns
- Shadow effects
- Border styles
- And more...

## How it Works

fig4ai follows a sophisticated process to transform your Figma designs into AI-ready context:

1. **Data Extraction**
   - Connects to Figma API and retrieves comprehensive file data
   - Processes complex nested JSON structure containing all design information

2. **Design Token Parsing**
   - Parses the JSON structure hierarchically: Canvas > Frame > Component / Instance
   - Extracts design tokens (colors, typography, spacing, effects)
   - Organizes components and their instances with style references
   - Maintains relationship between components and their variants

3. **AI-Powered Transformation**
   - For each Canvas, sends structured data to GPT-4o
   - Generates semantic pseudo-code with complete styling context
   - Preserves all design decisions, constraints, and relationships
   - Includes accessibility considerations and responsive behaviors

4. **Structured Documentation**
   - Stores all design tokens and pseudo-code representations in `.designrules`
   - Uses Markdown format for maximum compatibility
   - Maintains hierarchical structure of the design system
   - Preserves all style references and component relationships

5. **AI Context Integration**
   - `.designrules` file serves as a comprehensive design context
   - When mentioned in AI-powered IDEs (Cursor/Windsurf), the file is parsed
   - AI understands the complete design system and can generate accurate code
   - Enables context-aware code generation based on your design system

In essence, fig4ai transforms your Figma file into a structured AI context, making your design system programmatically accessible to AI tools.

## Usage

### Command Line

```bash
npx fig4ai <figma-url> [--model=claude|gpt4] [--no-ai]
```

Or if you've set `FIGMA_DESIGN_URL` in your `.env` file:

```bash
npx fig4ai [--model=claude|gpt4] [--no-ai]
```

### AI Options

The tool supports two AI models for enhanced design analysis:

1. **Claude (Default)**
   - Uses Anthropic's Claude 3 Sonnet model
   - Set `CLAUDE_API_KEY` in your environment variables
   - Generally better at understanding design context
   - More detailed component analysis

2. **GPT-4o**
   - Uses OpenAI's GPT-4 model
   - Set `OPENAI_API_KEY` in your environment variables
   - Alternative option if you prefer OpenAI

You can also run without AI enhancement:
```bash
npx fig4ai <figma-url> --no-ai
```
This will output raw design data in a structured format without AI processing.

### Environment Setup

```env
# Required
FIGMA_ACCESS_TOKEN=your_figma_token

# Optional - At least one needed for AI features
CLAUDE_API_KEY=your_claude_api_key
OPENAI_API_KEY=your_openai_api_key

# Optional
FIGMA_DESIGN_URL=your_default_figma_url
```

### Output

The tool generates a `.designrules` file containing:

- Design token documentation
- Component specifications
- Layout structures
- AI-generated pseudo-code
- Style references
- Accessibility considerations

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

If you encounter any issues or have questions, please:
1. Check the [issues page](https://github.com/f/fig4ai/issues)
2. Create a new issue if your problem isn't already listed
</file>

</files>
